var searchIndex = {};
searchIndex['nue_macros'] = {"items":[[0,"","nue_macros","`#[derive(..)]` attributes for POD and binary encodable types.",null,null]],"paths":[]};
searchIndex['nue_codegen'] = {"items":[[0,"","nue_codegen","nue derive syntax extension.",null,null],[5,"register","","Registers the plugin for expansion with syntex.",null,{"inputs":[{"name":"registry"}],"output":null}]],"paths":[]};
searchIndex['pod'] = {"items":[[0,"","pod","Provides traits that assist with I/O and byte slice conversions involving Plain Old Data.",null,null],[0,"code","","I/O traits for POD and other types.",null,null],[3,"VecDecodeOptions","pod::code","Describes how to decode a `Vec<T>`",null,null],[12,"len","","Reads `Some(len)` items, or until EOF",0,null],[12,"options","","The options used to decode each individual item",0,null],[3,"StringDecodeOptions","","Describes how to decode a `String`",null,null],[12,"len","","Reads `Some(len)` bytes, or until EOF",1,null],[3,"CStringDecodeOptions","","Describes how to decode a `CString`",null,null],[12,"require_nul","","When true, errors if EOF is reached before a nul byte is found",2,null],[8,"Encode","","Encodes an value's binary representation to a `Write`.",null,null],[16,"Options","","Options that may be provided to affect how the value is encoded",3,null],[11,"encode","","Encodes to the `Write` with default options",3,{"inputs":[{"name":"encode"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode_options","","Encodes to the `Write` with the provided options",3,{"inputs":[{"name":"encode"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode_vec","","Encodes to a new byte vector",3,{"inputs":[{"name":"encode"}],"output":{"name":"result"}}],[11,"encode_vec_options","","Encodes to a new byte vector with the provided options",3,{"inputs":[{"name":"encode"},{"name":"options"}],"output":{"name":"result"}}],[8,"Decode","","Decodes data from a `Read` into a new value.",null,null],[16,"Options","","Options will affect how the value is decoded, and may be used to provide any data that\nis normally lost during encoding.",4,null],[11,"decode","","Decodes from the `Read` with default options",4,{"inputs":[{"name":"decode"},{"name":"r"}],"output":{"name":"result"}}],[11,"decode_options","","Decodes from the `Read` with the provided options",4,{"inputs":[{"name":"decode"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"decode_slice","","Decodes from a byte slice",4,null],[11,"decode_slice_options","","Decodes from a byte slice with the provided options",4,null],[11,"validate","","Implement to assert that the decoded contents are valid",4,{"inputs":[{"name":"decode"}],"output":{"name":"result"}}],[11,"encode","core::option","",5,{"inputs":[{"name":"option"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode_options","","",5,{"inputs":[{"name":"option"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[11,"decode","","",5,{"inputs":[{"name":"option"},{"name":"r"}],"output":{"name":"result"}}],[11,"decode_options","","",5,{"inputs":[{"name":"option"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"decode_options","collections::string","",6,{"inputs":[{"name":"string"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","","",6,{"inputs":[{"name":"string"},{"name":"w"}],"output":{"name":"result"}}],[11,"decode_options","std::ffi::c_str","",7,{"inputs":[{"name":"cstring"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","","",7,{"inputs":[{"name":"cstring"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode","","",8,{"inputs":[{"name":"cstr"},{"name":"w"}],"output":{"name":"result"}}],[11,"decode_options","collections::vec","",9,{"inputs":[{"name":"vec"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","","",9,{"inputs":[{"name":"vec"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode_options","","",9,{"inputs":[{"name":"vec"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[11,"fmt","pod::code","",0,{"inputs":[{"name":"vecdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[{"name":"vecdecodeoptions"}],"output":{"name":"vecdecodeoptions"}}],[11,"clone","","",0,{"inputs":[{"name":"vecdecodeoptions"}],"output":{"name":"vecdecodeoptions"}}],[11,"fmt","","",1,{"inputs":[{"name":"stringdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[{"name":"stringdecodeoptions"}],"output":{"name":"stringdecodeoptions"}}],[11,"clone","","",1,{"inputs":[{"name":"stringdecodeoptions"}],"output":{"name":"stringdecodeoptions"}}],[11,"fmt","","",2,{"inputs":[{"name":"cstringdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[{"name":"cstringdecodeoptions"}],"output":{"name":"cstringdecodeoptions"}}],[11,"clone","","",2,{"inputs":[{"name":"cstringdecodeoptions"}],"output":{"name":"cstringdecodeoptions"}}],[0,"endian","pod","Containers for primitives",null,null],[3,"EndianPrimitive","pod::endian","A POD container for a primitive that stores a value in the specified endianness\nin memory, and transforms on `get`/`set`",null,null],[6,"Le","","A type alias for little endian primitives",null,null],[6,"Be","","A type alias for big endian primitives",null,null],[8,"EndianConvert","","Describes a value that can be converted to and from a specified byte order.",null,null],[10,"from","","Converts a value from `B`",10,{"inputs":[{"name":"endianconvert"}],"output":{"name":"self"}}],[10,"to","","Converts a value to `B`",10,{"inputs":[{"name":"endianconvert"}],"output":{"name":"self"}}],[11,"new","","Creates a new value",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":{"name":"self"}}],[11,"get","","Transforms to the native value",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"t"}}],[11,"set","","Transforms from a native value",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":null}],[11,"default","","",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"self"}}],[11,"from","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"endianprimitive"}],"output":{"name":"bool"}}],[11,"hash","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"h"}],"output":null}],[11,"clone","","",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"self"}}],[8,"Pod","pod","A marker trait indicating that a type is Plain Old Data.",null,null],[8,"PodExt","","Helper methods for converting POD types to/from byte slices and vectors",null,null],[11,"as_slice","","Borrows the POD as a byte slice",12,null],[11,"mut_slice","","Borrows the POD as a mutable byte slice",12,null],[11,"from_slice","","Borrows a new instance of the POD from a byte slice",12,null],[11,"from_mut_slice","","Borrows a mutable instance of the POD from a mutable byte slice",12,null],[11,"from_vec","","Converts a byte vector to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"vec"}],"output":{"name":"box"}}],[11,"from_box","","Converts a boxed slice to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"box"}],"output":{"name":"box"}}],[11,"map","","Converts a POD type from one to another of the same size.",12,{"inputs":[{"name":"podext"}],"output":{"name":"t"}}],[11,"map_mut","","Converts a POD type from one to another of the same size.",12,{"inputs":[{"name":"podext"}],"output":{"name":"t"}}],[11,"as_slice","","Borrows the POD as a byte slice",12,null],[11,"mut_slice","","Borrows the POD as a mutable byte slice",12,null],[11,"from_slice","","Borrows a new instance of the POD from a byte slice",12,null],[11,"from_mut_slice","","Borrows a mutable instance of the POD from a mutable byte slice",12,null],[11,"from_vec","","Converts a byte vector to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"vec"}],"output":{"name":"box"}}],[11,"from_box","","Converts a boxed slice to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"box"}],"output":{"name":"box"}}],[11,"map","","Converts a POD type from one to another of the same size.",12,{"inputs":[{"name":"podext"}],"output":{"name":"t"}}],[11,"map_mut","","Converts a POD type from one to another of the same size.",12,{"inputs":[{"name":"podext"}],"output":{"name":"t"}}]],"paths":[[3,"VecDecodeOptions"],[3,"StringDecodeOptions"],[3,"CStringDecodeOptions"],[8,"Encode"],[8,"Decode"],[4,"Option"],[3,"String"],[3,"CString"],[3,"CStr"],[3,"Vec"],[8,"EndianConvert"],[3,"EndianPrimitive"],[8,"PodExt"]]};
searchIndex['nue_io'] = {"items":[[0,"","nue_io","Utilities for working with I/O streams.",null,null],[3,"BufSeeker","","A buffered reader that allows for seeking within the buffer.",null,null],[3,"Region","","Creates an isolated segment of an underlying stream.",null,null],[3,"Take","","Wraps around a stream to limit the length of the underlying stream.",null,null],[0,"read_exact","","An extension for `Read`ing an exact amount of data.",null,null],[11,"fmt","byteorder::new","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"from","std::io::error","",1,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","byteorder::new","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"read_u16","byteorder","",2,null],[11,"read_u32","","",2,null],[11,"read_u64","","",2,null],[11,"read_uint","","",2,null],[11,"write_u16","","",2,null],[11,"write_u32","","",2,null],[11,"write_u64","","",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[4,"Error","nue_io::read_exact","An error type for reading bytes.",null,null],[13,"UnexpectedEOF","","An unexpected EOF.",0,null],[13,"Io","","Any underlying IO error that occurs while reading bytes.",0,null],[8,"ReadExactExt","","Extension trait that provides `read_exact` for all `Read` implementations.",null,null],[10,"read_exact","","Reads into the entirety of `buf` or fails with an error.",4,null],[0,"seek_forward","nue_io","Extensions for seeking around streams that do not normally support it.",null,null],[3,"SeekForwardRead","nue_io::seek_forward","A forward seeking wrapper around a `Read` type.",null,null],[3,"SeekForwardRewind","","A forward seeking wrapper around a `Read + SeekRewind` type.",null,null],[3,"SeekForwardWrite","","A forward seeking wrapper around a `Write` type.",null,null],[8,"SeekForward","","Extension trait that wraps a stream in a new forward seeker.",null,null],[10,"seek_forward","","Creates a new `SeekForward*` wrapper around the underlying stream.",5,{"inputs":[{"name":"seekforward"}],"output":{"name":"t"}}],[8,"SeekRewind","","A limited form of seeking that can only be reset from the beginning.",null,null],[10,"rewind","","Seeks back to the beginning of the stream.\nConceptually equivalent to `seek(SeekFrom::Start(0))`.",6,{"inputs":[{"name":"seekrewind"}],"output":{"name":"result"}}],[11,"seek","","",7,{"inputs":[{"name":"seekforwardread"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"seek","","",8,{"inputs":[{"name":"seekforwardrewind"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"seek","","",9,{"inputs":[{"name":"seekforwardwrite"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"read","","",7,null],[11,"fill_buf","","",7,{"inputs":[{"name":"seekforwardread"}],"output":{"name":"result"}}],[11,"consume","","",7,{"inputs":[{"name":"seekforwardread"},{"name":"usize"}],"output":null}],[11,"read","","",8,null],[11,"fill_buf","","",8,{"inputs":[{"name":"seekforwardrewind"}],"output":{"name":"result"}}],[11,"consume","","",8,{"inputs":[{"name":"seekforwardrewind"},{"name":"usize"}],"output":null}],[11,"write","","",9,null],[11,"flush","","",9,{"inputs":[{"name":"seekforwardwrite"}],"output":{"name":"result"}}],[11,"new","nue_io","Creates a new `BufSeeker` around the specified `Read`.",10,{"inputs":[{"name":"bufseeker"},{"name":"t"}],"output":{"name":"self"}}],[11,"with_capacity","","Creates a `BufSeeker` with a specific buffer size.",10,{"inputs":[{"name":"bufseeker"},{"name":"usize"},{"name":"t"}],"output":{"name":"self"}}],[11,"into_inner","","Unwraps the `BufSeeker`, returning the underlying reader.",10,{"inputs":[{"name":"bufseeker"}],"output":{"name":"t"}}],[11,"seek","","",10,{"inputs":[{"name":"bufseeker"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"read","","",10,null],[11,"fill_buf","","",10,{"inputs":[{"name":"bufseeker"}],"output":{"name":"result"}}],[11,"consume","","",10,{"inputs":[{"name":"bufseeker"},{"name":"usize"}],"output":null}],[11,"new","","Creates a new `Region` at the specified offsets of `inner`.",11,{"inputs":[{"name":"region"},{"name":"u64"},{"name":"u64"},{"name":"t"}],"output":{"name":"self"}}],[11,"region","","Returns the region bounds.",11,null],[11,"into_inner","","Unwraps the `Region` to return the inner stream.",11,{"inputs":[{"name":"region"}],"output":{"name":"t"}}],[11,"read","","",11,null],[11,"write","","",11,null],[11,"flush","","",11,{"inputs":[{"name":"region"}],"output":{"name":"result"}}],[11,"seek","","",11,{"inputs":[{"name":"region"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"fill_buf","","",11,{"inputs":[{"name":"region"}],"output":{"name":"result"}}],[11,"consume","","",11,{"inputs":[{"name":"region"},{"name":"usize"}],"output":null}],[11,"new","","Creates a new `Take` with `limit` bytes",12,{"inputs":[{"name":"take"},{"name":"t"},{"name":"u64"}],"output":{"name":"self"}}],[11,"write","","",12,null],[11,"flush","","",12,{"inputs":[{"name":"take"}],"output":{"name":"result"}}],[11,"read","","",12,null],[11,"seek","","",12,{"inputs":[{"name":"take"},{"name":"seekfrom"}],"output":{"name":"result"}}],[8,"SeekAlignExt","","An extension trait that will seek to meet a specified alignment.",null,null],[10,"align_to","","Seeks forward to a multiple of `alignment`.",13,{"inputs":[{"name":"seekalignext"},{"name":"u64"}],"output":{"name":"result"}}]],"paths":[[4,"Error"],[3,"Error"],[4,"BigEndian"],[4,"LittleEndian"],[8,"ReadExactExt"],[8,"SeekForward"],[8,"SeekRewind"],[3,"SeekForwardRead"],[3,"SeekForwardRewind"],[3,"SeekForwardWrite"],[3,"BufSeeker"],[3,"Region"],[3,"Take"],[8,"SeekAlignExt"]]};
searchIndex['uninitialized'] = {"items":[[0,"","uninitialized","Provides the option to use uninitialized memory for performance improvements.",null,null],[5,"uninitialized","","Creates a value initialized to zero.",null,{"inputs":[],"output":{"name":"t"}}],[17,"UNINITIALIZED","","A constant indicating whether the `uninitialized` feature is enabled.",null,null]],"paths":[]};
initSearch(searchIndex);
