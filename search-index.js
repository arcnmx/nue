var searchIndex = {};
searchIndex['pod'] = {"items":[[0,"","pod","Provides traits that assist with I/O and byte slice conversions involving Plain Old Data.",null,null],[0,"code","","I/O traits for POD and other types.",null,null],[3,"VecDecodeOptions","pod::code","Describes how to decode a `Vec<T>`",null,null],[12,"len","","Reads `Some(len)` items, or until EOF",0,null],[12,"options","","The options used to decode each individual item",0,null],[3,"StringDecodeOptions","","Describes how to decode a `String`",null,null],[12,"len","","Reads `Some(len)` bytes, or until EOF",1,null],[3,"CStringDecodeOptions","","Describes how to decode a `CString`",null,null],[12,"require_nul","","When true, errors if EOF is reached before a nul byte is found",2,null],[8,"Encode","","Encodes an value's binary representation to a `Write`.",null,null],[16,"Options","","Options that may be provided to affect how the value is encoded",3,null],[11,"encode","","Encodes to the `Write` with default options",3,{"inputs":[{"name":"encode"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode_options","","Encodes to the `Write` with the provided options",3,{"inputs":[{"name":"encode"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[8,"Decode","","Decodes data from a `Read` into a new value.",null,null],[16,"Options","","Options will affect how the value is decoded, and may be used to provide any data that\nis normally lost during encoding.",4,null],[11,"decode","","Decodes from the `Read` with default options",4,{"inputs":[{"name":"decode"},{"name":"r"}],"output":{"name":"result"}}],[11,"decode_options","","Decodes from the `Read` with the provided options",4,{"inputs":[{"name":"decode"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","core::option","",5,{"inputs":[{"name":"option"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode_options","","",5,{"inputs":[{"name":"option"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[11,"decode","","",5,{"inputs":[{"name":"option"},{"name":"r"}],"output":{"name":"result"}}],[11,"decode_options","","",5,{"inputs":[{"name":"option"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"decode_options","collections::string","",6,{"inputs":[{"name":"string"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","","",6,{"inputs":[{"name":"string"},{"name":"w"}],"output":{"name":"result"}}],[11,"decode_options","std::ffi::c_str","",7,{"inputs":[{"name":"cstring"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode","","",7,{"inputs":[{"name":"cstring"},{"name":"w"}],"output":{"name":"result"}}],[11,"encode","","",8,{"inputs":[{"name":"cstr"},{"name":"w"}],"output":{"name":"result"}}],[11,"decode_options","collections::vec","",9,{"inputs":[{"name":"vec"},{"name":"r"},{"name":"options"}],"output":{"name":"result"}}],[11,"encode_options","","",9,{"inputs":[{"name":"vec"},{"name":"w"},{"name":"options"}],"output":{"name":"result"}}],[11,"fmt","pod::code","",0,{"inputs":[{"name":"vecdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[{"name":"vecdecodeoptions"}],"output":{"name":"vecdecodeoptions"}}],[11,"clone","","",0,{"inputs":[{"name":"vecdecodeoptions"}],"output":{"name":"vecdecodeoptions"}}],[11,"fmt","","",1,{"inputs":[{"name":"stringdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[{"name":"stringdecodeoptions"}],"output":{"name":"stringdecodeoptions"}}],[11,"clone","","",1,{"inputs":[{"name":"stringdecodeoptions"}],"output":{"name":"stringdecodeoptions"}}],[11,"fmt","","",2,{"inputs":[{"name":"cstringdecodeoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[{"name":"cstringdecodeoptions"}],"output":{"name":"cstringdecodeoptions"}}],[11,"clone","","",2,{"inputs":[{"name":"cstringdecodeoptions"}],"output":{"name":"cstringdecodeoptions"}}],[0,"endian","pod","Containers for primitives",null,null],[3,"EndianPrimitive","pod::endian","A POD container for a primitive that stores a value in the specified endianness\nin memory, and transforms on `get`/`set`",null,null],[6,"Le","","A type alias for little endian primitives",null,null],[6,"Be","","A type alias for big endian primitives",null,null],[8,"EndianConvert","","Describes a value that can be converted to and from a specified byte order.",null,null],[10,"from","","Converts a value from `B`",10,{"inputs":[{"name":"endianconvert"}],"output":{"name":"self"}}],[10,"to","","Converts a value to `B`",10,{"inputs":[{"name":"endianconvert"}],"output":{"name":"self"}}],[11,"new","","Creates a new value",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":{"name":"self"}}],[11,"get","","Transforms to the native value",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"t"}}],[11,"set","","Transforms from a native value",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":null}],[11,"default","","",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"self"}}],[11,"from","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"endianprimitive"}],"output":{"name":"bool"}}],[11,"hash","","",11,{"inputs":[{"name":"endianprimitive"},{"name":"h"}],"output":null}],[11,"clone","","",11,{"inputs":[{"name":"endianprimitive"}],"output":{"name":"self"}}],[8,"Pod","pod","A marker trait indicating that a type is Plain Old Data.",null,null],[8,"PodType","","An unsafe marker trait that indicates a type can be used as Plain Old Data.\nShould be used very carefully to mark a type as POD when it contains a non-POD\nmember such as a reference.",null,null],[8,"PodExt","","Helper methods for converting Plain Old Data types to/from byte slices and vectors",null,null],[11,"as_slice","","Borrows the POD as a byte slice",12,null],[11,"mut_slice","","Borrows the POD as a mutable byte slice",12,null],[11,"from_slice","","Borrows a new instance of the POD from a byte slice",12,null],[11,"from_mut_slice","","Borrows a mutable instance of the POD from a mutable byte slice",12,null],[11,"from_vec","","Converts a byte vector to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"vec"}],"output":{"name":"box"}}],[11,"from_box","","Converts a boxed slice to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"box"}],"output":{"name":"box"}}],[11,"as_slice","","Borrows the POD as a byte slice",12,null],[11,"mut_slice","","Borrows the POD as a mutable byte slice",12,null],[11,"from_slice","","Borrows a new instance of the POD from a byte slice",12,null],[11,"from_mut_slice","","Borrows a mutable instance of the POD from a mutable byte slice",12,null],[11,"from_vec","","Converts a byte vector to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"vec"}],"output":{"name":"box"}}],[11,"from_box","","Converts a boxed slice to a boxed instance of the POD type",12,{"inputs":[{"name":"podext"},{"name":"box"}],"output":{"name":"box"}}]],"paths":[[3,"VecDecodeOptions"],[3,"StringDecodeOptions"],[3,"CStringDecodeOptions"],[8,"Encode"],[8,"Decode"],[4,"Option"],[3,"String"],[3,"CString"],[3,"CStr"],[3,"Vec"],[8,"EndianConvert"],[3,"EndianPrimitive"],[8,"PodExt"]]};
searchIndex['nue_io'] = {"items":[[0,"","nue_io","Utilities for working with I/O streams.",null,null],[0,"read_exact","","An extension for `Read`ing an exact amount of data.",null,null],[11,"fmt","byteorder::new","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"from","std::io::error","",1,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","byteorder::new","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"read_u16","byteorder","",2,null],[11,"read_u32","","",2,null],[11,"read_u64","","",2,null],[11,"read_uint","","",2,null],[11,"write_u16","","",2,null],[11,"write_u32","","",2,null],[11,"write_u64","","",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[4,"Error","nue_io::read_exact","An error type for reading bytes.",null,null],[13,"UnexpectedEOF","","An unexpected EOF.",0,null],[13,"Io","","Any underlying IO error that occurs while reading bytes.",0,null],[8,"ReadExact","","Extension trait that provides `read_exact` for all `Read` implementations.",null,null],[10,"read_exact","","Reads into the entirety of `buf` or fails with an error.",4,null]],"paths":[[4,"Error"],[3,"Error"],[4,"BigEndian"],[4,"LittleEndian"],[8,"ReadExact"]]};
searchIndex['uninitialized'] = {"items":[[0,"","uninitialized","Provides the option to use uninitialized memory for performance improvements.",null,null],[5,"uninitialized","","Creates a value initialized to zero.",null,{"inputs":[],"output":{"name":"t"}}],[17,"UNINITIALIZED","","A constant indicating whether the `uninitialized` feature is enabled.",null,null]],"paths":[]};
initSearch(searchIndex);
